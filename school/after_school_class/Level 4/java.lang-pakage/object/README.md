# Object 클래스

- 자바의 **모든 클래스의 최상위 부모 클래스**는 항상 **`Object`** 클래스임.<br><br>

# Object 클래스가 최상위 부모 클래스인 이유

## 1. 공통 기능 제공

- 객체의 정보를 제공하고, 이 객체가 다른 객체와 같은지 비교하고, 객체가 어떤 클래스로 만들어졌는지 확인하는 기능은 모든 객체가 필요로 하는 기능임.
- 이런 기능을 객체를 만들 때마다 항상 새로운 메서드를 정의해서 만들어야 한다면 상당히 번거로울 것임.
- 막상 만든다고 해도 개발자마다 서로 다른 이름의 메서드를 만들어서 일관성이 없을 것임.
- 개발자는 모든 객체가 앞서 설명한 메서드를 지원한다는 것을 알고 있으면 프로그래밍이 단순화되고, 일관성을 갖게 됨.

## 2. 다형성의 기본 구현

- 부모는 자식을 담을 수 있음.
- Object는 모든 클래스의 부모 클래스임.
- 따라서 모든 객체를 참조할 수 있음.
- 이는 다양한 타입의 객체를 통합적으로 관리할 수 있게 함.
- Object는 모든 객체를 담을 수 있기에 타입이 다른 객체들을 어딘가에 보관해야 한다면 Object에 보관하면 됨.
  - 서로 공통점이 없는 객체들을 한 곳에 모아두려고 할 때 Object를 사용하면 됨.
 
# Object의 다형성

- Object는 모든 클래스의 부모 클래스임.
- 따라서 Object는 모든 객체를 참조할 수 있음.<br><br>
![image](https://github.com/wkdtjdwns/Java/assets/128266768/008ca4eb-b458-45e9-b346-81e4a9e54a0d)

# Object를 활용한 다형성 한계

- Object는 모든 객체를 대상으로 다형적 참조를 할 수 있음.
  
    - 즉, Object는 모든 객체의 부모이므로 모든 객체를 담을 수 있음.
    
- Object를 통해 전달 받은 객체를 호출하려면 각 객체에 맞는 다운 캐스팅 과정이 필요함.
  
    - Object가 세상의 모든 메서드를 알고 있는 것은 아님.
    
- 다형성을 제대로 활용하려면 다형적 참조 + 메서드 오버라이딩을 함께 사용해야 함.
- Object는 모든 객체의 부모이므로 모든 객체를 대상으로 다형적 참조를 할 수 있음.
- 하지만 Object에는 Dog.sound(), Car.move()와 같은 다른 객체의 메서드가 정의되어 있지 않음.
- 따라서 메서드 오버라이딩을 활용할 수 없음.
- 결국 각 객체의 기능을 호출하려면 다운 캐스팅을 해야 함.
    
    ---
    
## 결론

- 다형적 참조는 가능함.
- 하지만 메서드 오버라이딩이 안되기 때문에 다형성을 활용하기에는 한계가 있음.
    
# Object의 사용 방법

- Object[] 배열을 만들면 세상의 모든 객체를 담을 수 있는 배열을 생성할 수 있음.

# Object가 없다면?

- `void action(Object obj)`과 같이 모든 객체를 받을 수 있는 메서드를 만들 수 없음.
- **`Object[] objects`** 처럼 모든 객체를 저장할 수 있는 배열을 만들 수 없음.
- 만약 대체하기 위해서 MyObject와 같은 클래스를 만들고 모든 클래스에서 직접 정의한 MyObject를 상속 받으면 해당 기능을 구현할 수는 있지만, 하나의 프로젝트를 넘어 전계계 모든 개발자가 비슷한 클래스를 만들 것이고, 서로 호환되지 않는 수많은 XxxObject들이 넘쳐날 것임.
