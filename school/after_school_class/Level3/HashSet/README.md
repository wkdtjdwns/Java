# HashSet

### 특정 데이터를 찾을 때

---

- 배열을 사용한다고 하면 특정 값을 찾을 때 배열의 길이가 많다면 엄청나게 오래 걸림. → 처음부터 아래로 내려가며 하나하나 찾기 때문.
- 그 문제를 해결하고자 **해시 함수**라는 것을 사용함.
- **해시 함수**는 찾을 데이터가 대강 어디에 있을지 예측하고 그 예측 값부터 찾기 시작하도록 구현함.
    
    ![image](https://github.com/wkdtjdwns/Java/assets/128266768/6ba99740-3988-4c51-aacb-46dcfae6e7b5)

    
    데이터의 크기와 시간의 관계
    

---

### HashSet

---

- set `인터페이스`에서 지원하는 구현 클래스임.
    
    ```
    ⭐ 인터페이스 = 구현 되어있지 않고 정의만 되어 있는 것!
    
    ```
    
- 순서대로 입력되지 않고, 일정하게 유지되지 않음.
- null 요소도 허용됨.
- ⭐ 중복을 허용하지 않음. (hashset의 매력적인 부분임.)

---

- 중복을 걸러내는 과정
    1. 객체를 저장하기 전에 먼저 객체의 hashCode() 메소드를 호출해서 해시 코드를 얻어 냄
    2. 저장되어 있는 객체들의 해시 코드와 비교한 뒤
    3. 같은 해시 코드가 있다면 다시 equals() 메소드로 두 객체를 비교해서 true가 나오면 동일한 객체로 판단하고 중복 저장을 하지 않음.
    
    ```
    💡 이 때 비교하는 것은 문자열의 주소 값이 아닌 문자열 자체의 값을 비교하는 것임. (==으로 비교해도 됨.)
    ```
    
---

- **선언** : `HashSet<클래스> 변수명 = new HashSet<클래스>();`
- **메소드**
    
    ---
    
    - `add(value)` : 값 추가
    - `remove(value)` : value 값 제거
    - `clear()` : 모든 값 삭제
    - `size()` : HashSet 크기
    - `contains(value)` : value 값이 있는 지 확인
    
    ---
    
- ⭐ **출력**
    - 전체 출력 : `System.out.println(변수명);`
    - ⭐ get 메소드가 존재 하지 않아서 하나의 객체를 가지고 올 수 없음.
    - 하나의 객체를 가져오기 위해서는 `Iterator`를 사용해야 함.
        - 전체 객체를 대상으로 한 번씩 반복해서 가져오는 **반복자**임.
        - `Iterator()` 메소드를 호출하면 얻을 수 있음.
        - `Iterator`에서 하나의 객체를 가져올 때는 `next()` 메소드를 사용함.
        - 객체를 가져오기에 앞서 가져올 객체가 있는지 확인하기 위해 `hasNext()` 매소드를 사용해 확인하는 것이 좋음.
            - `hasNext()` : 가져올 객체가 있으면 true 아니면 false 반환.
        
        ---
        
        - `Iterator` 사용법
      <br>
        
        ```java
        Iterator 변수명 = 해시셋변수명.Iterator();
        while (변수명.hasNext()) {
        	System.out.println(변수명.next());
        }
        ```
